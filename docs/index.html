<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>LP Race Tracker</title>
  <style>
    :root{
      /* Dark “broadcast” palette (not neon-glass) */
      --bg0:#070A12;
      --bg1:#0A1020;
      --panel:#0B1224;
      --panel2:#0A1226;

      --line: rgba(255,255,255,0.10);
      --line2: rgba(255,255,255,0.14);

      --text:#EAF0FF;
      --muted: rgba(234,240,255,0.68);

      --accent:#86D2C5;   /* teal */
      --accent2:#F0C36A;  /* gold */
      --danger:#E06C75;   /* red */

      --radius: 18px;
      --shadow: 0 18px 60px rgba(0,0,0,0.55);
    }

    *{ box-sizing:border-box; }
    html, body{ height:100%; }

    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: var(--text);
      background:
        radial-gradient(1200px 800px at 10% 0%, rgba(134,210,197,0.11), transparent 55%),
        radial-gradient(900px 700px at 100% 20%, rgba(240,195,106,0.10), transparent 55%),
        radial-gradient(1200px 900px at 50% 120%, rgba(134,210,197,0.08), transparent 55%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
    }

    /* subtle “film grain” */
    body::before{
      content:"";
      position:fixed;
      inset:0;
      pointer-events:none;
      background:
        repeating-linear-gradient(0deg, rgba(255,255,255,0.025) 0, rgba(255,255,255,0.025) 1px, transparent 1px, transparent 6px),
        repeating-linear-gradient(90deg, rgba(255,255,255,0.015) 0, rgba(255,255,255,0.015) 1px, transparent 1px, transparent 10px);
      opacity:0.20;
      mix-blend-mode: overlay;
    }

    /* Wider container so cards fill big monitors */
    .wrap{
      width: min(1700px, calc(100vw - 40px));
      margin: 18px auto 40px;
    }

    .top{
      display:flex;
      justify-content:space-between;
      align-items:flex-end;
      gap:16px;
      margin-bottom: 14px;
    }

    .brand{
      display:flex;
      flex-direction:column;
      gap:8px;
    }

    h1{
      margin:0;
      font-size: 30px;
      letter-spacing: 0.8px;
      font-weight: 900;
      text-transform: uppercase;
    }

    .sub{
      font-size: 13px;
      color: var(--muted);
      letter-spacing: 0.35px;
    }

    .updated{
      text-align:right;
      font-size: 13px;
      color: var(--muted);
      line-height: 1.35;
      white-space: nowrap;
    }

    .grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 18px;
    }

    @media (max-width: 980px){
      .wrap{ width: min(980px, calc(100vw - 26px)); margin-top: 14px; }
      .grid{ grid-template-columns: 1fr; }
      .updated{ text-align:left; white-space: normal; }
      .top{ flex-direction:column; align-items:flex-start; }
    }

    .board{
      background: linear-gradient(180deg, rgba(11,18,36,0.92), rgba(10,18,38,0.86));
      border: 1px solid var(--line2);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
      position:relative;
      min-height: 560px;
    }

    /* angular “broadcast” corner marker */
    .board::after{
      content:"";
      position:absolute;
      top:0;
      right:0;
      width: 180px;
      height: 180px;
      background: linear-gradient(135deg, rgba(134,210,197,0.10), rgba(240,195,106,0.08), transparent 70%);
      clip-path: polygon(100% 0, 0 0, 100% 100%);
      pointer-events:none;
    }

    .hdr{
      padding: 18px 18px 14px;
      border-bottom: 1px solid var(--line);
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap: 14px;
    }

    .name{
      display:flex;
      flex-direction:column;
      gap:6px;
      min-width: 0;
    }

    .riot{
      margin:0;
      font-size: 20px;
      font-weight: 900;
      letter-spacing: 0.3px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .key{
      font-size: 12px;
      color: var(--muted);
      display:flex;
      align-items:center;
      gap:8px;
    }

    code{
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.10);
      padding: 2px 7px;
      border-radius: 999px;
      color: rgba(234,240,255,0.90);
    }

    .rankBox{
      text-align:right;
      display:flex;
      flex-direction:column;
      gap:8px;
      flex-shrink:0;
    }

    .rankLine{
      font-size: 12px;
      color: var(--muted);
    }

    .rankBig{
      font-size: 18px;
      font-weight: 900;
      letter-spacing:0.25px;
    }

    .body{
      padding: 16px 18px 18px;
    }

    .sectionTitle{
      display:flex;
      justify-content:space-between;
      align-items:baseline;
      gap:10px;
      margin-bottom: 10px;
    }

    .sectionTitle .t{
      font-size: 12px;
      letter-spacing: 0.35px;
      color: var(--muted);
      text-transform: uppercase;
      font-weight: 800;
    }

    .sectionTitle .pct{
      font-size: 12px;
      font-weight: 900;
      color: rgba(234,240,255,0.88);
      letter-spacing:0.35px;
    }

    .progressStack{
      display:flex;
      flex-direction:column;
      gap: 14px;
      margin-top: 6px;
    }

    .track{
      height: 14px;
      border-radius: 999px;
      background: rgba(255,255,255,0.055);
      border: 1px solid rgba(255,255,255,0.10);
      overflow:hidden;
      position:relative;
    }

    /* segmented ticks inside the bar (5 milestones => 5 slots visually) */
    .track::before{
      content:"";
      position:absolute;
      inset:0;
      background:
        repeating-linear-gradient(
          90deg,
          transparent 0,
          transparent calc(20% - 1px),
          rgba(255,255,255,0.10) calc(20% - 1px),
          rgba(255,255,255,0.10) 20%
        );
      opacity:0.65;
      pointer-events:none;
    }

    .fill{
      height:100%;
      width:0%;
      border-radius: 999px;
      background: linear-gradient(90deg, rgba(134,210,197,0.95), rgba(240,195,106,0.90));
      transition: width 300ms ease;
      box-shadow: 0 0 0 1px rgba(0,0,0,0.18) inset;
    }

    .milestones{
      display:flex;
      justify-content:space-between;
      margin-top: 10px;
      font-size: 11px;
      color: rgba(234,240,255,0.55);
    }
    .milestones span{
      position:relative;
      padding-top: 10px;
      flex:1;
      text-align:center;
    }
    .milestones span::before{
      content:"";
      position:absolute;
      top:0;
      left:50%;
      transform:translateX(-50%);
      width:2px;
      height:7px;
      background: rgba(255,255,255,0.20);
      border-radius: 2px;
    }
    .milestones span.on{
      color: rgba(234,240,255,0.90);
      font-weight: 900;
    }
    .milestones span.on::before{
      background: rgba(240,195,106,0.80);
    }

    .kpi{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-top: 16px;
    }
    @media (max-width: 560px){
      .kpi{ grid-template-columns: 1fr; }
    }

    .tile{
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.04);
      border-radius: 14px;
      padding: 12px 12px 11px;
    }

    .tile .k{
      font-size: 12px;
      color: rgba(234,240,255,0.62);
      margin-bottom: 6px;
      letter-spacing:0.25px;
    }
    .tile .v{
      font-size: 16px;
      font-weight: 900;
      letter-spacing:0.2px;
      line-height: 1.15;
    }

    .small{
      font-size: 12px;
      color: rgba(234,240,255,0.58);
      line-height: 1.35;
      margin-top: 12px;
      border-top: 1px solid var(--line);
      padding-top: 12px;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="top">
      <div class="brand">
        <h1>LP Race Tracker</h1>
        <div class="sub">NA • Solo/Duo • Goal: Emerald IV (0 LP)</div>
      </div>
      <div class="updated" id="updated">Last Updated: …</div>
    </div>

    <div class="grid" id="cards"></div>
  </div>

<script>
  // ---------------------------
  // Champion ID -> Name mapping
  // ---------------------------
  // Loads Data Dragon champion.json, then exposes champName(id).
  // This stays entirely in index.html.
  const CHAMPION_CACHE_KEY = "champMap_v1";
  const CHAMPION_CACHE_TTL_MS = 1000 * 60 * 60 * 24 * 7; // 7 days
  let CHAMP_ID_TO_NAME = {};

  async function loadChampionMap(){
    // Try localStorage cache first
    try{
      const raw = localStorage.getItem(CHAMPION_CACHE_KEY);
      if (raw){
        const cached = JSON.parse(raw);
        if (cached && cached.ts && cached.data && (Date.now() - cached.ts) < CHAMPION_CACHE_TTL_MS){
          CHAMP_ID_TO_NAME = cached.data;
          return;
        }
      }
    }catch(_){}

    // Find the latest Data Dragon version
    let version = null;
    try{
      const verRes = await fetch("https://ddragon.leagueoflegends.com/api/versions.json", { cache: "no-store" });
      const versions = await verRes.json();
      version = Array.isArray(versions) ? versions[0] : null;
    }catch(_){}

    // Fallback version if version endpoint fails
    if (!version) version = "14.1.1";

    // Fetch champion list and build id -> name
    const url = `https://ddragon.leagueoflegends.com/cdn/${version}/data/en_US/champion.json`;
    const champRes = await fetch(url, { cache: "no-store" });
    const champJson = await champRes.json();

    const map = {};
    const champs = champJson?.data || {};
    for (const key of Object.keys(champs)){
      const c = champs[key];
      // c.key is numeric string id
      if (c && c.key && c.name){
        map[String(c.key)] = c.name;
      }
    }
    CHAMP_ID_TO_NAME = map;

    // Save to cache
    try{
      localStorage.setItem(CHAMPION_CACHE_KEY, JSON.stringify({ ts: Date.now(), data: map }));
    }catch(_){}
  }

  function champName(id){
    if (id == null) return "n/a";
    const k = String(id);
    return CHAMP_ID_TO_NAME[k] || k; // fallback to the id if missing
  }

  // ---------------------------
  // Time formatting (America/New_York)
  // ---------------------------
  function formatLastUpdated(isoString){
    if (!isoString) return { display: "Last Updated: unknown", rel: "" };

    const dt = new Date(isoString);
    const parts = new Intl.DateTimeFormat("en-US", {
      timeZone: "America/New_York",
      month: "2-digit",
      day: "2-digit",
      hour: "numeric",
      minute: "2-digit",
      hour12: true
    }).formatToParts(dt);

    const get = (type) => parts.find(p => p.type === type)?.value;
    const mm = get("month");
    const dd = get("day");
    const hh = get("hour");
    const min = get("minute");
    const ap = get("dayPeriod"); // AM/PM

    const display = `Last Updated: ${hh}:${min}${ap} on ${mm}/${dd}`;

    const now = new Date();
    const diffSec = Math.max(0, Math.floor((now - dt) / 1000));

    let rel;
    if (diffSec < 10) rel = "just now";
    else if (diffSec < 60) rel = `${diffSec} seconds ago`;
    else if (diffSec < 3600) rel = `${Math.floor(diffSec/60)} minutes ago`;
    else if (diffSec < 86400) rel = `${Math.floor(diffSec/3600)} hours ago`;
    else rel = `${Math.floor(diffSec/86400)} days ago`;

    return { display, rel };
  }

  // ---------------------------
  // Rank model
  // ---------------------------
  const tierOrder = {
    "IRON": 0, "BRONZE": 1, "SILVER": 2, "GOLD": 3,
    "PLATINUM": 4, "EMERALD": 5, "DIAMOND": 6,
    "MASTER": 7, "GRANDMASTER": 8, "CHALLENGER": 9
  };
  const divOrder = {"IV": 0, "III": 1, "II": 2, "I": 3};

  function rankValue(tier, div, lp){
    const t = tierOrder[tier] ?? -1;
    const d = divOrder[div] ?? 0;
    const L = Number.isFinite(lp) ? lp : 0;
    return t * 10000 + d * 1000 + L;
  }

  // ---------------------------
  // Progress bar definitions (stacked)
  // ---------------------------
  // Each bar is "from X4 @ 0 LP" to "nextTier4 @ 0 LP"
  const BARS = [
    {
      title: "Progress to Gold",
      start: { tier: "SILVER", div: "IV", lp: 0 },
      end:   { tier: "GOLD",   div: "IV", lp: 0 },
      milestones: [
        { tier: "SILVER", div:"IV", label:"S4" },
        { tier: "SILVER", div:"III", label:"S3" },
        { tier: "SILVER", div:"II", label:"S2" },
        { tier: "SILVER", div:"I", label:"S1" },
        { tier: "GOLD",   div:"IV", label:"G4" },
      ]
    },
    {
      title: "Progress to Platinum",
      start: { tier: "GOLD", div: "IV", lp: 0 },
      end:   { tier: "PLATINUM", div: "IV", lp: 0 },
      milestones: [
        { tier: "GOLD", div:"IV", label:"G4" },
        { tier: "GOLD", div:"III", label:"G3" },
        { tier: "GOLD", div:"II", label:"G2" },
        { tier: "GOLD", div:"I", label:"G1" },
        { tier: "PLATINUM", div:"IV", label:"P4" },
      ]
    },
    {
      title: "Progress to Emerald",
      start: { tier: "PLATINUM", div: "IV", lp: 0 },
      end:   { tier: "EMERALD",  div: "IV", lp: 0 },
      milestones: [
        { tier: "PLATINUM", div:"IV", label:"P4" },
        { tier: "PLATINUM", div:"III", label:"P3" },
        { tier: "PLATINUM", div:"II", label:"P2" },
        { tier: "PLATINUM", div:"I", label:"P1" },
        { tier: "EMERALD",  div:"IV", label:"E4" },
      ]
    },
  ];

  function computeBarProgress(cur, bar){
    if (!cur) return { pct: 0, reachedIndex: -1 };

    const curV = rankValue(cur.tier, cur.division, cur.lp);
    const startV = rankValue(bar.start.tier, bar.start.div, bar.start.lp);
    const endV   = rankValue(bar.end.tier,   bar.end.div,   bar.end.lp);

    let pct;
    if (curV < startV) pct = 0;
    else if (curV >= endV) pct = 1;
    else pct = (curV - startV) / (endV - startV);

    let reachedIndex = -1;
    for (let i = 0; i < bar.milestones.length; i++){
      const m = bar.milestones[i];
      const mv = rankValue(m.tier, m.div, 0);
      if (curV >= mv) reachedIndex = i;
    }

    return { pct: Math.max(0, Math.min(1, pct)), reachedIndex };
  }

  function curLabel(cur){
    if (!cur) return "Unranked / placements";
    return `${cur.tier} ${cur.division} — ${cur.lp} LP`;
  }

  async function load(){
    // Load champion mapping BEFORE rendering cards
    await loadChampionMap();

    const res = await fetch("./data.json", { cache: "no-store" });
    const data = await res.json();

    const updatedIso = data?.updatedAt?.iso ?? data?.updatedAt;
    const { display, rel } = formatLastUpdated(updatedIso);
    document.getElementById("updated").textContent = rel ? `${display} (${rel})` : display;

    const cards = document.getElementById("cards");
    cards.innerHTML = "";

    for (const [key, p] of Object.entries(data.players || {})){
      const cur = p.current;
      const s = p.stats || {};
      const winrate = cur && cur.winrate != null ? (cur.winrate * 100).toFixed(1) + "%" : "n/a";
      const peakText = p.peak ? `${p.peak.tier} ${p.peak.division} — ${p.peak.lp} LP` : "n/a";

      const barsHtml = BARS.map((bar) => {
        const prog = computeBarProgress(cur, bar);
        const pctLabel = `${Math.round(prog.pct * 100)}%`;

        const milestoneHtml = bar.milestones.map((m, i) => {
          const cls = (i <= prog.reachedIndex) ? "on" : "";
          return `<span class="${cls}">${m.label}</span>`;
        }).join("");

        return `
          <div>
            <div class="sectionTitle">
              <div class="t">${bar.title}</div>
              <div class="pct">${pctLabel}</div>
            </div>
            <div class="track"><div class="fill" style="width:${(prog.pct*100).toFixed(2)}%"></div></div>
            <div class="milestones">${milestoneHtml}</div>
          </div>
        `;
      }).join("");

      const board = document.createElement("div");
      board.className = "board";
      board.innerHTML = `
        <div class="hdr">
          <div class="name">
            <h2 class="riot">${p.riotId}</h2>
            <div class="key">Key: <code>${key}</code></div>
          </div>
          <div class="rankBox">
            <div class="rankLine">Current</div>
            <div class="rankBig">${curLabel(cur)}</div>
            <div class="rankLine">Peak (since tracking): ${peakText}</div>
          </div>
        </div>

        <div class="body">
          <div class="progressStack">
            ${barsHtml}
          </div>

          <div class="kpi">
            <div class="tile">
              <div class="k">Games (Solo/Duo)</div>
              <div class="v">${cur ? cur.games : (s.games ?? 0)} (W ${cur ? cur.wins : (s.wins ?? 0)} / L ${cur ? cur.losses : (s.losses ?? 0)})</div>
            </div>
            <div class="tile">
              <div class="k">Overall winrate</div>
              <div class="v">${winrate}</div>
            </div>
            <div class="tile">
              <div class="k">Total playtime (tracked)</div>
              <div class="v">${s.totalPlaytimeHMS || "0:00:00"}</div>
            </div>
            <div class="tile">
              <div class="k">Most played champ</div>
              <div class="v">${champName(s.mostPlayedChampionId)}</div>
            </div>
            <div class="tile">
              <div class="k">Highest WR champ (min 5 games)</div>
              <div class="v">${s.highestWinrateChampionId != null ? champName(s.highestWinrateChampionId) : "n/a"}${s.highestWinrateChampionWR != null ? ` • ${(s.highestWinrateChampionWR*100).toFixed(1)}%` : ""}</div>
            </div>
            <div class="tile">
              <div class="k">Lowest WR champ (min 5 games)</div>
              <div class="v">${s.lowestWinrateChampionId != null ? champName(s.lowestWinrateChampionId) : "n/a"}${s.lowestWinrateChampionWR != null ? ` • ${(s.lowestWinrateChampionWR*100).toFixed(1)}%` : ""}</div>
            </div>
          </div>

          <div class="small">
            LP deltas are best-effort. Dodges/remakes/promos and multi-game gaps can skew average LP gain/loss.
          </div>
        </div>
      `;
      cards.appendChild(board);
    }

    // Update "(x minutes ago)" every 10s without refetching
    setInterval(() => {
      const updatedIso2 = data?.updatedAt?.iso ?? data?.updatedAt;
      const { display: d2, rel: r2 } = formatLastUpdated(updatedIso2);
      document.getElementById("updated").textContent = r2 ? `${d2} (${r2})` : d2;
    }, 10000);
  }

  load();
</script>
</body>
</html>
